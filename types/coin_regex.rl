// Code generated by regel using `ragel -Z coin_regex.rl` . DO NOT EDIT.
// source: types/coin_regex.rl
// nolint:gocritic,unused,ineffassign


// Regex parsing of denoms were as the following
// reDnmString = `[a-zA-Z][a-zA-Z0-9/:._-]{2,127}`
// reDecAmt    = `[[:digit:]]+(?:\.[[:digit:]]+)?|\.[[:digit:]]+`
// reSpc       = `[[:space:]]*`

// reDnm = regexp.MustCompile(fmt.Sprintf(`^%s$`, coinDenomRegex()))
// reDecCoin = regexp.MustCompile(fmt.Sprintf(`^(%s)%s(%s)$`, reDecAmt, reSpc, coinDenomRegex()))

package types

func MatchDenom(data []byte) bool {
%% machine scanner;
%% write data;

    if len(data) < 3 || len(data) > 128 {
        return false
    }
    cs, p, pe, eof := 0, 0, len(data), len(data)
    _ = eof
    %%{
        # Define character classes
        special = '/' | ':' | '.' | '_' | '-';

        denom_pattern = [a-zA-Z] (alnum | special);


        # Combined pattern for matching either a denomination or a decimal amount
        main := denom_pattern  @{ return true };

        write init;
        write exec;
    }%%
    return false
}

func MatchDecCoin(data []byte) (amountStart, amountEnd, denomStart, denomEnd int, isValid bool) {

    %% machine dec_coin;
    %% write data;

    // Initialize positions and validity flag
    amountStart, amountEnd, denomStart, denomEnd = -1, -1, -1, -1
    isValid = false

    // Ragel state variables
    var cs, p, pe, eof int
    p, pe, eof = 0, len(data), len(data)

    %%{
        action StartAmount {
            amountStart = p;
        }
        action EndAmount {
            amountEnd = p;
        }
        action StartDenom {
            denomStart =  p-1;
        }
        action EndDenom {
            denomEnd = p-1; // Adjusted to exclude space if present
        }
        action MarkValid {
            isValid = true;
        }

        special = '/' | ':' | '.' | '_' | '-';

        dec_amt = (digit+ >StartAmount ('.' digit+)? %EndAmount) | ('.' >StartAmount digit+ %EndAmount);

        
        denom = [a-zA-Z] (alnum | special){2,127} >StartDenom %EndDenom;

        main := dec_amt (space* denom)?;

        write init;
        write exec;
    }%%

    isValid = (cs >= %%{ write first_final; }%%);

    // Return the captured positions and validity
    return amountStart, amountEnd, denomStart, denomEnd, isValid
}
